{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"spatial-kfold","text":"<p>spatial-kfold: A Python Package for Spatial Resampling Toward More Reliable Cross-Validation in Spatial Studies.</p> <p>spatial-kfold is a python library for performing spatial resampling to ensure more robust cross-validation in spatial studies. It offers spatial clustering and block resampling technique with user-friendly parameters to customize the resampling. It enables users to conduct a \"Leave Region Out\" cross-validation, which can be useful for evaluating the model's generalization to new locations as well as improving the reliability of feature selection and hyperparameter tuning in spatial studies.</p> <p>spatial-kfold can be integrated easily with scikit-learn's LeaveOneGroupOut cross-validation technique. This integration enables you to further leverage the resampled spatial data for performing feature selection and hyperparameter tuning.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Conduct Leave Region Out using two spatial resampling techniques:</li> <li>Spatial clustering with KMeans or BisectingKMeans</li> <li> <p>Spatial blocks</p> <ul> <li>Random blocks</li> <li> <p>Continuous blocks</p> </li> <li> <p><code>tb-lr</code> (top-bottom, left-right)</p> </li> <li><code>bt-rl</code> (bottom-top, right-left)</li> </ul> </li> <li> <p>Integrates easily with scikit-learn\u2019s <code>LeaveOneGroupOut</code> cross-validation to enable advanced feature selection and hyperparameter tuning.</p> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install spatial-kfold directly from PyPI:</p> <pre><code>pip install spatial-kfold\n</code></pre>"},{"location":"#credits","title":"Credits","text":"<p>This package was inspired by the following R packages:</p> <ul> <li>CAST</li> <li>spatialsample </li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<p>This project relies on the following dependencies:</p> <ul> <li>pandas</li> <li>numpy</li> <li>geopandas</li> <li>shapely</li> <li>matplotlib</li> <li>scikit-learn</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use My Package in your research or work, please cite it using the following entries:</p> <ul> <li>MLA Style:</li> </ul> <p><pre><code>Ghariani, Walid. \"spatial-kfold: A Python Package for Spatial Resampling Toward More Reliable Cross-Validation in Spatial Studies.\" 2023. GitHub, https://github.com/WalidGharianiEAGLE/spatial-kfold\n</code></pre> - BibTex Style:</p> <pre><code>@Misc{spatial-kfold,\nauthor = {Walid Ghariani},\ntitle = {spatial-kfold: A Python Package for Spatial Resampling Toward More Reliable Cross-Validation in Spatial Studies},\nhowpublished = {GitHub},\nyear = {2023},\nurl = {https://github.com/WalidGharianiEAGLE/spatial-kfold}\n}\n</code></pre>"},{"location":"#resources","title":"Resources","text":"<p>A list of tutorials and resources mainly in R explaining the importance of spatial resampling and spatial cross validation</p> <ul> <li>Hanna Meyer: \"Machine-learning based modelling of spatial and spatio-temporal data\"</li> <li>Jannes M\u00fcnchow: \"The importance of spatial cross-validation in predictive modeling\"</li> <li>Julia Silge: Spatial resampling for more reliable model evaluation with geographic data </li> </ul>"},{"location":"#bibliography","title":"Bibliography","text":"<p>Meyer, H., Reudenbach, C., W\u00f6llauer, S., Nauss, T. (2019): Importance of spatial predictor variable selection in machine learning applications - Moving from data reproduction to spatial prediction. Ecological Modelling. 411. https://doi.org/10.1016/j.ecolmodel.2019.108815</p> <p>Schratz, Patrick, et al. \"Hyperparameter tuning and performance assessment of statistical and machine-learning algorithms using spatial data.\" Ecological Modelling 406 (2019): 109-120. https://doi.org/10.1016/j.ecolmodel.2019.06.002</p> <p>Schratz, Patrick, et al. \"mlr3spatiotempcv: Spatiotemporal resampling methods for machine learning in R.\" arXiv preprint arXiv:2110.12674 (2021). https://arxiv.org/abs/2110.12674</p> <p>Valavi, Roozbeh, et al. \"blockCV: An r package for generating spatially or environmentally separated folds for k-fold cross-validation of species distribution models.\" Biorxiv (2018): 357798. https://doi.org/10.1101/357798 </p>"},{"location":"usage/","title":"Usage","text":"<pre><code>import geopandas as gpd\n\nfrom spatialkfold.datasets import load_ames\nfrom spatialkfold.blocks import spatial_blocks \nfrom spatialkfold.clusters import spatial_kfold_clusters \n</code></pre>"},{"location":"usage/#spatial-cluster-resampling","title":"Spatial cluster resampling","text":"<pre><code>ames = load_ames()\names_prj = ames.copy().to_crs(ames.estimate_utm_crs())\names_prj['id'] = range(len(ames_prj))\n\names_clusters = spatial_kfold_clusters(\n  gdf=ames_prj, \n  name='id', \n  nfolds=10, \n  algorithm='kmeans', # \"bisectingkmeans\"\n  n_init=\"auto\", \n  random_state=569\n  ) \n</code></pre>"},{"location":"usage/#spatially-resampled-blocks","title":"Spatially resampled blocks","text":"<pre><code># create 10 random/continuous blocks \names_rnd_blocks = spatial_blocks(\n  gdf=ames_prj, \n  width=1500, \n  height=1500, \n  method=\"random\",     # \"continuous\"\n  orientation=\"tb-lr\", # \"bt-rl\"\n  grid_type=\"rect\",    # \"hex\" \n  nfolds=10, \n  random_state=135\n  )\n\n# resample the ames data with the prepared blocks \names_res_rnd_blk = gpd.overlay(ames_prj, ames_rnd_blocks) \n</code></pre>"},{"location":"notebooks/spatialkfold_intro/","title":"I. Spatial Resampling","text":"In\u00a0[2]: Copied! <pre>import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport geopandas as gpd\nfrom sklearn import preprocessing\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import KFold \nfrom sklearn.model_selection import LeaveOneGroupOut \nfrom sklearn.model_selection import cross_validate\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nimport matplotlib.colors as colors\nfrom matplotlib.colors import ListedColormap, LinearSegmentedColormap\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\n\nfrom spatialkfold.blocks import spatial_blocks \nfrom spatialkfold.datasets import load_ames\nfrom spatialkfold.clusters import spatial_kfold_clusters \nfrom spatialkfold.plotting import spatial_kfold_plot\nfrom spatialkfold.stats import spatial_kfold_stats\n</pre> import numpy as np import pandas as pd import seaborn as sns import geopandas as gpd from sklearn import preprocessing from sklearn.linear_model import LinearRegression from sklearn.model_selection import KFold  from sklearn.model_selection import LeaveOneGroupOut  from sklearn.model_selection import cross_validate import matplotlib.pyplot as plt from matplotlib import cm import matplotlib.colors as colors from matplotlib.colors import ListedColormap, LinearSegmentedColormap from mpl_toolkits.axes_grid1.inset_locator import inset_axes  from spatialkfold.blocks import spatial_blocks  from spatialkfold.datasets import load_ames from spatialkfold.clusters import spatial_kfold_clusters  from spatialkfold.plotting import spatial_kfold_plot from spatialkfold.stats import spatial_kfold_stats In\u00a0[3]: Copied! <pre>ames = load_ames()\n</pre> ames = load_ames() In\u00a0[4]: Copied! <pre>ames.crs\n</pre> ames.crs Out[4]: <pre>&lt;Geographic 2D CRS: EPSG:4326&gt;\nName: WGS 84\nAxis Info [ellipsoidal]:\n- Lat[north]: Geodetic latitude (degree)\n- Lon[east]: Geodetic longitude (degree)\nArea of Use:\n- name: World.\n- bounds: (-180.0, -90.0, 180.0, 90.0)\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich</pre> In\u00a0[5]: Copied! <pre>ames\n</pre> ames Out[5]: MS_SubClass MS_Zoning Lot_Frontage Lot_Area Street Alley Lot_Shape Land_Contour Utilities Lot_Config ... Pool_QC Fence Misc_Feature Misc_Val Mo_Sold Year_Sold Sale_Type Sale_Condition Sale_Price geometry 0 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 141.0 31770 Pave No_Alley_Access Slightly_Irregular Lvl AllPub Corner ... No_Pool No_Fence None 0 5 2010 WD Normal 215000 POINT (-93.61975 42.05403) 1 One_Story_1946_and_Newer_All_Styles Residential_High_Density 80.0 11622 Pave No_Alley_Access Regular Lvl AllPub Inside ... No_Pool Minimum_Privacy None 0 6 2010 WD Normal 105000 POINT (-93.61976 42.05301) 2 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 81.0 14267 Pave No_Alley_Access Slightly_Irregular Lvl AllPub Corner ... No_Pool No_Fence Gar2 12500 6 2010 WD Normal 172000 POINT (-93.61939 42.05266) 3 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 93.0 11160 Pave No_Alley_Access Regular Lvl AllPub Corner ... No_Pool No_Fence None 0 4 2010 WD Normal 244000 POINT (-93.61732 42.05125) 4 Two_Story_1946_and_Newer Residential_Low_Density 74.0 13830 Pave No_Alley_Access Slightly_Irregular Lvl AllPub Inside ... No_Pool Minimum_Privacy None 0 3 2010 WD Normal 189900 POINT (-93.63893 42.06090) ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 2925 Split_or_Multilevel Residential_Low_Density 37.0 7937 Pave No_Alley_Access Slightly_Irregular Lvl AllPub CulDSac ... No_Pool Good_Privacy None 0 3 2006 WD Normal 142500 POINT (-93.60478 41.98896) 2926 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 0.0 8885 Pave No_Alley_Access Slightly_Irregular Low AllPub Inside ... No_Pool Minimum_Privacy None 0 6 2006 WD Normal 131000 POINT (-93.60268 41.98831) 2927 Split_Foyer Residential_Low_Density 62.0 10441 Pave No_Alley_Access Regular Lvl AllPub Inside ... No_Pool Minimum_Privacy Shed 700 7 2006 WD Normal 132000 POINT (-93.60685 41.98651) 2928 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 77.0 10010 Pave No_Alley_Access Regular Lvl AllPub Inside ... No_Pool No_Fence None 0 4 2006 WD Normal 170000 POINT (-93.60019 41.99092) 2929 Two_Story_1946_and_Newer Residential_Low_Density 74.0 9627 Pave No_Alley_Access Regular Lvl AllPub Inside ... No_Pool No_Fence None 0 11 2006 WD Normal 188000 POINT (-93.60000 41.98927) <p>2930 rows \u00d7 73 columns</p> In\u00a0[6]: Copied! <pre># Reproject to the approriate coordinate reference system \n</pre> # Reproject to the approriate coordinate reference system  In\u00a0[7]: Copied! <pre>ames_prj = ames.copy().to_crs(ames.estimate_utm_crs())\n</pre> ames_prj = ames.copy().to_crs(ames.estimate_utm_crs()) In\u00a0[8]: Copied! <pre>ames_prj.crs\n</pre> ames_prj.crs Out[8]: <pre>&lt;Derived Projected CRS: EPSG:32615&gt;\nName: WGS 84 / UTM zone 15N\nAxis Info [cartesian]:\n- E[east]: Easting (metre)\n- N[north]: Northing (metre)\nArea of Use:\n- name: Between 96\u00b0W and 90\u00b0W, northern hemisphere between equator and 84\u00b0N, onshore and offshore. Canada - Manitoba; Nunavut; Ontario. Ecuador -Galapagos. Guatemala. Mexico. United States (USA).\n- bounds: (-96.0, 0.0, -90.0, 84.0)\nCoordinate Operation:\n- name: UTM zone 15N\n- method: Transverse Mercator\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich</pre> In\u00a0[9]: Copied! <pre># Add an id column for each data point \n</pre> # Add an id column for each data point  In\u00a0[10]: Copied! <pre>ames_prj['id'] = range(len(ames_prj))\n</pre> ames_prj['id'] = range(len(ames_prj)) In\u00a0[11]: Copied! <pre>ames_clusters = spatial_kfold_clusters(\n    gdf=ames_prj, \n    name='id', \n    nfolds= 10, \n    algorithm='kmeans', \n    n_init=\"auto\", \n    random_state =569) \n</pre> ames_clusters = spatial_kfold_clusters(     gdf=ames_prj,      name='id',      nfolds= 10,      algorithm='kmeans',      n_init=\"auto\",      random_state =569)  In\u00a0[12]: Copied! <pre>ames_clusters\n</pre> ames_clusters Out[12]: MS_SubClass MS_Zoning Lot_Frontage Lot_Area Street Alley Lot_Shape Land_Contour Utilities Lot_Config ... Misc_Feature Misc_Val Mo_Sold Year_Sold Sale_Type Sale_Condition Sale_Price geometry id folds 0 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 141.0 31770 Pave No_Alley_Access Slightly_Irregular Lvl AllPub Corner ... None 0 5 2010 WD Normal 215000 POINT (448716.789 4655961.485) 0 9 1 One_Story_1946_and_Newer_All_Styles Residential_High_Density 80.0 11622 Pave No_Alley_Access Regular Lvl AllPub Inside ... None 0 6 2010 WD Normal 105000 POINT (448715.802 4655848.124) 1 9 2 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 81.0 14267 Pave No_Alley_Access Slightly_Irregular Lvl AllPub Corner ... Gar2 12500 6 2010 WD Normal 172000 POINT (448746.026 4655808.487) 2 9 3 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 93.0 11160 Pave No_Alley_Access Regular Lvl AllPub Corner ... None 0 4 2010 WD Normal 244000 POINT (448915.962 4655650.253) 3 9 4 Two_Story_1946_and_Newer Residential_Low_Density 74.0 13830 Pave No_Alley_Access Slightly_Irregular Lvl AllPub Inside ... None 0 3 2010 WD Normal 189900 POINT (447135.458 4656735.276) 4 2 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 2925 Split_or_Multilevel Residential_Low_Density 37.0 7937 Pave No_Alley_Access Slightly_Irregular Lvl AllPub CulDSac ... None 0 3 2006 WD Normal 142500 POINT (449905.137 4648727.785) 2925 3 2926 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 0.0 8885 Pave No_Alley_Access Slightly_Irregular Low AllPub Inside ... None 0 6 2006 WD Normal 131000 POINT (450078.246 4648654.392) 2926 3 2927 Split_Foyer Residential_Low_Density 62.0 10441 Pave No_Alley_Access Regular Lvl AllPub Inside ... Shed 700 7 2006 WD Normal 132000 POINT (449731.661 4648456.532) 2927 3 2928 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 77.0 10010 Pave No_Alley_Access Regular Lvl AllPub Inside ... None 0 4 2006 WD Normal 170000 POINT (450286.530 4648942.397) 2928 3 2929 Two_Story_1946_and_Newer Residential_Low_Density 74.0 9627 Pave No_Alley_Access Regular Lvl AllPub Inside ... None 0 11 2006 WD Normal 188000 POINT (450301.311 4648758.419) 2929 3 <p>2930 rows \u00d7 75 columns</p> In\u00a0[13]: Copied! <pre># Get the 'tab20' colormap\ncols_tab = cm.get_cmap('tab20', 10)\n# Generate a list of colors from the colormap\ncols = [cols_tab(i) for i in range(10)]\n# create a color ramp\ncolor_ramp = ListedColormap(cols)\n</pre> # Get the 'tab20' colormap cols_tab = cm.get_cmap('tab20', 10) # Generate a list of colors from the colormap cols = [cols_tab(i) for i in range(10)] # create a color ramp color_ramp = ListedColormap(cols) In\u00a0[14]: Copied! <pre>fig, ax = plt.subplots(1,1 , figsize=(9, 4)) \names_clusters.plot(column='folds', ax=ax, cmap=color_ramp, markersize=2, legend=True)\nax.set_title('Spatially Clustered Folds\\nUsing KMeans')\nplt.show()\n</pre> fig, ax = plt.subplots(1,1 , figsize=(9, 4))  ames_clusters.plot(column='folds', ax=ax, cmap=color_ramp, markersize=2, legend=True) ax.set_title('Spatially Clustered Folds\\nUsing KMeans') plt.show() In\u00a0[15]: Copied! <pre># check the number of train and test of the dependent variable for each fold\n</pre> # check the number of train and test of the dependent variable for each fold In\u00a0[16]: Copied! <pre>ames_clusters_stats = spatial_kfold_stats(X=ames_clusters, y=ames_clusters.Sale_Price, groups=ames_clusters.folds)\n</pre> ames_clusters_stats = spatial_kfold_stats(X=ames_clusters, y=ames_clusters.Sale_Price, groups=ames_clusters.folds) In\u00a0[17]: Copied! <pre>ames_clusters_stats\n</pre> ames_clusters_stats Out[17]: split train test 0 1 2645 285 1 2 2427 503 2 3 2769 161 3 4 2645 285 4 5 2577 353 5 6 2568 362 6 7 2824 106 7 8 2658 272 8 9 2640 290 9 10 2617 313 In\u00a0[18]: Copied! <pre>ames_clusters_Biskmeans = spatial_kfold_clusters(\n    gdf=ames_prj, \n    name='id', \n    nfolds=10, \n    algorithm='bisectingkmeans',\n    random_state =569) \n</pre> ames_clusters_Biskmeans = spatial_kfold_clusters(     gdf=ames_prj,      name='id',      nfolds=10,      algorithm='bisectingkmeans',     random_state =569)  In\u00a0[19]: Copied! <pre>fig, ax = plt.subplots(1,1 , figsize=(9, 4)) \names_clusters_Biskmeans.plot(column='folds', ax=ax, cmap=color_ramp, markersize=2, legend=True)\nax.set_title('Spatially Clustered Folds\\nUsing BisectingKMeans')\nplt.show()\n</pre> fig, ax = plt.subplots(1,1 , figsize=(9, 4))  ames_clusters_Biskmeans.plot(column='folds', ax=ax, cmap=color_ramp, markersize=2, legend=True) ax.set_title('Spatially Clustered Folds\\nUsing BisectingKMeans') plt.show() In\u00a0[20]: Copied! <pre>ames_clusters_stats_ = spatial_kfold_stats(X=ames_clusters_Biskmeans, y=ames_clusters_Biskmeans.Sale_Price, groups=ames_clusters_Biskmeans.folds)\n</pre> ames_clusters_stats_ = spatial_kfold_stats(X=ames_clusters_Biskmeans, y=ames_clusters_Biskmeans.Sale_Price, groups=ames_clusters_Biskmeans.folds) In\u00a0[21]: Copied! <pre>ames_clusters_stats_\n</pre> ames_clusters_stats_ Out[21]: split train test 0 1 2561 369 1 2 2678 252 2 3 2633 297 3 4 2572 358 4 5 2457 473 5 6 2605 325 6 7 2759 171 7 8 2579 351 8 9 2769 161 9 10 2757 173 In\u00a0[22]: Copied! <pre># create 10 random blocks \names_rnd_blocks = spatial_blocks(\n  gdf=ames_prj, \n  width=1500, \n  height=1500, \n  method=\"random\",     # \"continuous\"\n  orientation=\"tb-lr\", # \"bt-rl\"\n  grid_type=\"rect\",    # \"hex\" \n  nfolds=10,\n  random_state=135\n  )\n</pre> # create 10 random blocks  ames_rnd_blocks = spatial_blocks(   gdf=ames_prj,    width=1500,    height=1500,    method=\"random\",     # \"continuous\"   orientation=\"tb-lr\", # \"bt-rl\"   grid_type=\"rect\",    # \"hex\"    nfolds=10,   random_state=135   ) In\u00a0[23]: Copied! <pre>fig, ax = plt.subplots(1,1 , figsize=(9, 4)) \n\names_rnd_blocks.plot(column='folds', cmap=color_ramp, ax=ax ,lw=0.7, legend=True)\names_prj.plot(ax=ax, markersize=1, color='r')\nax.set_title('Random Blocks Folds')\n</pre> fig, ax = plt.subplots(1,1 , figsize=(9, 4))   ames_rnd_blocks.plot(column='folds', cmap=color_ramp, ax=ax ,lw=0.7, legend=True) ames_prj.plot(ax=ax, markersize=1, color='r') ax.set_title('Random Blocks Folds') Out[23]: <pre>Text(0.5, 1.0, 'Random Blocks Folds')</pre> In\u00a0[24]: Copied! <pre># resample the ames data with the prepared blocks \names_res_rnd_blk = gpd.overlay(ames_prj, ames_rnd_blocks)\n</pre> # resample the ames data with the prepared blocks  ames_res_rnd_blk = gpd.overlay(ames_prj, ames_rnd_blocks) In\u00a0[25]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(9, 4)) \n\names_rnd_blocks.plot(facecolor=\"none\", edgecolor='grey', ax=ax, lw=0.7)\names_res_rnd_blk.plot(column='folds', cmap=color_ramp, legend=True, ax=ax, markersize=3)\nax.set_title('Spatially Resampled\\nRandom Blocks')\nplt.show()\n</pre> fig, ax = plt.subplots(1, 1, figsize=(9, 4))   ames_rnd_blocks.plot(facecolor=\"none\", edgecolor='grey', ax=ax, lw=0.7) ames_res_rnd_blk.plot(column='folds', cmap=color_ramp, legend=True, ax=ax, markersize=3) ax.set_title('Spatially Resampled\\nRandom Blocks') plt.show() In\u00a0[26]: Copied! <pre>fig, ax = plt.subplots(1,2 , figsize=(10, 6)) \n\n# plot 1\names_rnd_blocks.plot(column='folds', cmap=color_ramp, ax=ax[0] , lw=0.7, legend=False)\names_prj.plot(ax=ax[0], markersize=2, color='r')\nax[0].set_title('Random Blocks Folds')\n\n# plot 2\names_rnd_blocks.plot(facecolor=\"none\", edgecolor='grey', ax=ax[1], lw=0.7, legend=False)\names_res_rnd_blk.plot(column='folds', cmap=color_ramp, legend=False, ax=ax[1], markersize = 2)\nax[1].set_title('Spatially Resampled\\nrandom blocks')\n\n\nim1 = ax[1].scatter(ames_res_rnd_blk.geometry.x , ames_res_rnd_blk.geometry.y, c=ames_res_rnd_blk['folds'],\n                 cmap=color_ramp, s=5)\n\naxins1 = inset_axes(\n    ax[1],\n    width=\"5%\",  # width: 5% of parent_bbox width\n    height=\"50%\",  # height: 50%\n    loc=\"lower left\",\n    bbox_to_anchor=(1.05, 0, 1, 2),\n    bbox_transform=ax[1].transAxes,\n    borderpad=0\n)\nfig.colorbar(im1, cax=axins1, ticks= range(1,11))\n\n\nplt.show()\n</pre> fig, ax = plt.subplots(1,2 , figsize=(10, 6))   # plot 1 ames_rnd_blocks.plot(column='folds', cmap=color_ramp, ax=ax[0] , lw=0.7, legend=False) ames_prj.plot(ax=ax[0], markersize=2, color='r') ax[0].set_title('Random Blocks Folds')  # plot 2 ames_rnd_blocks.plot(facecolor=\"none\", edgecolor='grey', ax=ax[1], lw=0.7, legend=False) ames_res_rnd_blk.plot(column='folds', cmap=color_ramp, legend=False, ax=ax[1], markersize = 2) ax[1].set_title('Spatially Resampled\\nrandom blocks')   im1 = ax[1].scatter(ames_res_rnd_blk.geometry.x , ames_res_rnd_blk.geometry.y, c=ames_res_rnd_blk['folds'],                  cmap=color_ramp, s=5)  axins1 = inset_axes(     ax[1],     width=\"5%\",  # width: 5% of parent_bbox width     height=\"50%\",  # height: 50%     loc=\"lower left\",     bbox_to_anchor=(1.05, 0, 1, 2),     bbox_transform=ax[1].transAxes,     borderpad=0 ) fig.colorbar(im1, cax=axins1, ticks= range(1,11))   plt.show() In\u00a0[27]: Copied! <pre>ames_res_rnd_blk_stats = spatial_kfold_stats(X=ames_res_rnd_blk, y=ames_res_rnd_blk.Sale_Price, groups=ames_res_rnd_blk.folds)\n</pre> ames_res_rnd_blk_stats = spatial_kfold_stats(X=ames_res_rnd_blk, y=ames_res_rnd_blk.Sale_Price, groups=ames_res_rnd_blk.folds) In\u00a0[28]: Copied! <pre>ames_res_rnd_blk_stats\n</pre> ames_res_rnd_blk_stats Out[28]: split train test 0 1 2893 37 1 2 2371 559 2 3 2414 516 3 4 2472 458 4 5 2687 243 5 6 2608 322 6 7 2720 210 7 8 2589 341 8 9 2920 10 9 10 2696 234 <ul> <li>We could also use Hexagonal grid type instead</li> </ul> In\u00a0[\u00a0]: Copied! <pre># create 10 random blocks \names_rnd_blocks_hex = spatial_blocks(\n  gdf=ames_prj, \n  width=1500, \n  height=0,            # If you use hex as grid_type, only the width is needed. If you provide height, it will be ignored \n  method=\"random\",     # \"continuous\"\n  orientation=\"tb-lr\", # \"bt-rl\"\n  grid_type=\"hex\",   \n  nfolds=10,\n  random_state=135\n  )\names_res_rnd_blk_hex = gpd.overlay(ames_prj, ames_rnd_blocks_hex)\n</pre> # create 10 random blocks  ames_rnd_blocks_hex = spatial_blocks(   gdf=ames_prj,    width=1500,    height=0,            # If you use hex as grid_type, only the width is needed. If you provide height, it will be ignored    method=\"random\",     # \"continuous\"   orientation=\"tb-lr\", # \"bt-rl\"   grid_type=\"hex\",      nfolds=10,   random_state=135   ) ames_res_rnd_blk_hex = gpd.overlay(ames_prj, ames_rnd_blocks_hex) In\u00a0[30]: Copied! <pre>fig, ax = plt.subplots(1,2 , figsize=(10, 6)) \n\n# plot 1\names_rnd_blocks_hex.plot(column='folds', cmap=color_ramp, ax=ax[0] , lw=0.7, legend=False)\names_prj.plot(ax=ax[0], markersize=2, color='r')\nax[0].set_title('Random Blocks Folds')\n\n# plot 2\names_rnd_blocks_hex.plot(facecolor=\"none\", edgecolor='grey', ax=ax[1], lw=0.7, legend=False)\names_res_rnd_blk_hex.plot(column='folds', cmap=color_ramp, legend=False, ax=ax[1], markersize = 2)\nax[1].set_title('Spatially Resampled\\nrandom blocks')\n\n\nim1 = ax[1].scatter(ames_res_rnd_blk_hex.geometry.x , ames_res_rnd_blk_hex.geometry.y, c=ames_res_rnd_blk_hex['folds'],\n                 cmap=color_ramp, s=5)\n\naxins1 = inset_axes(\n    ax[1],\n    width=\"5%\",  # width: 5% of parent_bbox width\n    height=\"50%\",  # height: 50%\n    loc=\"lower left\",\n    bbox_to_anchor=(1.05, 0, 1, 2),\n    bbox_transform=ax[1].transAxes,\n    borderpad=0\n)\nfig.colorbar(im1, cax=axins1, ticks= range(1,11))\n\n\nplt.show()\n</pre> fig, ax = plt.subplots(1,2 , figsize=(10, 6))   # plot 1 ames_rnd_blocks_hex.plot(column='folds', cmap=color_ramp, ax=ax[0] , lw=0.7, legend=False) ames_prj.plot(ax=ax[0], markersize=2, color='r') ax[0].set_title('Random Blocks Folds')  # plot 2 ames_rnd_blocks_hex.plot(facecolor=\"none\", edgecolor='grey', ax=ax[1], lw=0.7, legend=False) ames_res_rnd_blk_hex.plot(column='folds', cmap=color_ramp, legend=False, ax=ax[1], markersize = 2) ax[1].set_title('Spatially Resampled\\nrandom blocks')   im1 = ax[1].scatter(ames_res_rnd_blk_hex.geometry.x , ames_res_rnd_blk_hex.geometry.y, c=ames_res_rnd_blk_hex['folds'],                  cmap=color_ramp, s=5)  axins1 = inset_axes(     ax[1],     width=\"5%\",  # width: 5% of parent_bbox width     height=\"50%\",  # height: 50%     loc=\"lower left\",     bbox_to_anchor=(1.05, 0, 1, 2),     bbox_transform=ax[1].transAxes,     borderpad=0 ) fig.colorbar(im1, cax=axins1, ticks= range(1,11))   plt.show() In\u00a0[31]: Copied! <pre>ames_cont_blocks = spatial_blocks(\n  gdf=ames_prj, \n  width=1500, \n  height=1500,            \n  method=\"continuous\",    \n  orientation=\"tb-lr\",\n  grid_type=\"rect\",   \n  nfolds=10,\n  random_state=135\n  )\n</pre> ames_cont_blocks = spatial_blocks(   gdf=ames_prj,    width=1500,    height=1500,               method=\"continuous\",       orientation=\"tb-lr\",   grid_type=\"rect\",      nfolds=10,   random_state=135   ) In\u00a0[32]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(9, 4)) \n\names_cont_blocks.plot(column='folds', cmap=color_ramp, ax=ax , lw=0.7, legend=True)\names_prj.plot(ax=ax, markersize=1, color='r')\nax.set_title('Continuous Blocks Folds\\norientation:\"tb-lr\"')\n</pre> fig, ax = plt.subplots(1, 1, figsize=(9, 4))   ames_cont_blocks.plot(column='folds', cmap=color_ramp, ax=ax , lw=0.7, legend=True) ames_prj.plot(ax=ax, markersize=1, color='r') ax.set_title('Continuous Blocks Folds\\norientation:\"tb-lr\"') Out[32]: <pre>Text(0.5, 1.0, 'Continuous Blocks Folds\\norientation:\"tb-lr\"')</pre> In\u00a0[33]: Copied! <pre># resample the ames data with the prepared blocks \names_res_cont_blk = gpd.overlay(ames_prj, ames_cont_blocks)\n</pre> # resample the ames data with the prepared blocks  ames_res_cont_blk = gpd.overlay(ames_prj, ames_cont_blocks) In\u00a0[34]: Copied! <pre>fig, ax = plt.subplots(1, 1, figsize=(9, 4)) \n\names_cont_blocks.plot(facecolor=\"none\", edgecolor='grey', ax=ax ,lw=0.7)\names_res_cont_blk.plot(column='folds', cmap=color_ramp, legend=True, ax=ax, markersize=2)\nax.set_title('Spatially Resampled\\nContinuous Blocks Folds. \"tb-lr\"')\nplt.show()\n</pre> fig, ax = plt.subplots(1, 1, figsize=(9, 4))   ames_cont_blocks.plot(facecolor=\"none\", edgecolor='grey', ax=ax ,lw=0.7) ames_res_cont_blk.plot(column='folds', cmap=color_ramp, legend=True, ax=ax, markersize=2) ax.set_title('Spatially Resampled\\nContinuous Blocks Folds. \"tb-lr\"') plt.show() In\u00a0[35]: Copied! <pre>ames_res_cont_blk_stats = spatial_kfold_stats(X=ames_res_cont_blk, y=ames_res_cont_blk.Sale_Price, groups=ames_res_cont_blk.folds)\n</pre> ames_res_cont_blk_stats = spatial_kfold_stats(X=ames_res_cont_blk, y=ames_res_cont_blk.Sale_Price, groups=ames_res_cont_blk.folds) In\u00a0[36]: Copied! <pre>ames_res_cont_blk_stats\n</pre> ames_res_cont_blk_stats Out[36]: split train test 0 1 2446 484 1 2 2628 302 2 3 2801 129 3 4 2567 363 4 5 2367 563 5 6 2402 528 6 7 2894 36 7 8 2444 486 8 9 2896 34 9 10 2925 5 In\u00a0[37]: Copied! <pre>ames_cont_blocks_rev = spatial_blocks(\n  gdf=ames_prj, \n  width=1500, \n  height=1500,            \n  method=\"continuous\",    \n  orientation='bt-rl',\n  grid_type=\"rect\",   \n  nfolds=10,\n  random_state=135\n  )\n</pre> ames_cont_blocks_rev = spatial_blocks(   gdf=ames_prj,    width=1500,    height=1500,               method=\"continuous\",       orientation='bt-rl',   grid_type=\"rect\",      nfolds=10,   random_state=135   ) In\u00a0[38]: Copied! <pre>fig, ax = plt.subplots(1, 1 , figsize=(9, 4)) \n\names_cont_blocks_rev.plot(column='folds',cmap=color_ramp, ax=ax , lw=0.7, legend=True)\names_prj.plot(ax=ax, markersize=1, color='r')\nax.set_title('Continuous Blocks Folds\\norientation:\"bt-rl\"')\n</pre> fig, ax = plt.subplots(1, 1 , figsize=(9, 4))   ames_cont_blocks_rev.plot(column='folds',cmap=color_ramp, ax=ax , lw=0.7, legend=True) ames_prj.plot(ax=ax, markersize=1, color='r') ax.set_title('Continuous Blocks Folds\\norientation:\"bt-rl\"') Out[38]: <pre>Text(0.5, 1.0, 'Continuous Blocks Folds\\norientation:\"bt-rl\"')</pre> In\u00a0[39]: Copied! <pre># resample the ames data with the prepared blocks \names_res_cont_blk_rev = gpd.overlay(ames_prj, ames_cont_blocks_rev)\n</pre> # resample the ames data with the prepared blocks  ames_res_cont_blk_rev = gpd.overlay(ames_prj, ames_cont_blocks_rev) In\u00a0[40]: Copied! <pre>fig, ax = plt.subplots(1, 1 , figsize=(9, 4)) \n\names_cont_blocks_rev.plot(facecolor=\"none\", edgecolor='grey', ax=ax, lw=0.7)\names_res_cont_blk_rev.plot(column='folds', cmap=color_ramp, legend=True, ax=ax, markersize=2)\nax.set_title('Spatially Resampled\\nContinuous Blocks Folds. \"bt-rl\"')\nplt.show()\n</pre> fig, ax = plt.subplots(1, 1 , figsize=(9, 4))   ames_cont_blocks_rev.plot(facecolor=\"none\", edgecolor='grey', ax=ax, lw=0.7) ames_res_cont_blk_rev.plot(column='folds', cmap=color_ramp, legend=True, ax=ax, markersize=2) ax.set_title('Spatially Resampled\\nContinuous Blocks Folds. \"bt-rl\"') plt.show() In\u00a0[41]: Copied! <pre>ames_res_cont_blk_rev_stats = spatial_kfold_stats(X=ames_res_cont_blk_rev, y=ames_res_cont_blk_rev.Sale_Price, groups=ames_res_cont_blk_rev.folds)\n</pre> ames_res_cont_blk_rev_stats = spatial_kfold_stats(X=ames_res_cont_blk_rev, y=ames_res_cont_blk_rev.Sale_Price, groups=ames_res_cont_blk_rev.folds) In\u00a0[42]: Copied! <pre>ames_res_cont_blk_rev_stats\n</pre> ames_res_cont_blk_rev_stats Out[42]: split train test 0 1 2892 38 1 2 2443 487 2 3 2776 154 3 4 2350 580 4 5 2306 624 5 6 2758 172 6 7 2841 89 7 8 2772 158 8 9 2783 147 9 10 2449 481 In\u00a0[43]: Copied! <pre># check the folds number \nnp.unique(ames_clusters.folds.values)\n</pre> # check the folds number  np.unique(ames_clusters.folds.values) Out[43]: <pre>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10], dtype=int32)</pre> In\u00a0[44]: Copied! <pre>for i in range(1,11):\n    fig, ax = plt.subplots(1, 1 ,figsize=(9, 4))\n\n    spatial_kfold_plot(X=ames_clusters, \n                       geometry=ames_clusters.geometry, \n                       groups=ames_clusters.folds, \n                       fold_num=i, cmap='viridis', ax=ax)\n</pre> for i in range(1,11):     fig, ax = plt.subplots(1, 1 ,figsize=(9, 4))      spatial_kfold_plot(X=ames_clusters,                         geometry=ames_clusters.geometry,                         groups=ames_clusters.folds,                         fold_num=i, cmap='viridis', ax=ax) In\u00a0[45]: Copied! <pre>x = ames_prj[['Year_Built', 'Bldg_Type', 'Gr_Liv_Area']]\ny = ames_prj[['Sale_Price']]\n\nle = preprocessing.LabelEncoder()\nle.fit(x[\"Bldg_Type\"])\n\nlist(le.classes_)\n\nle.transform(ames_prj[\"Bldg_Type\"])\n</pre> x = ames_prj[['Year_Built', 'Bldg_Type', 'Gr_Liv_Area']] y = ames_prj[['Sale_Price']]  le = preprocessing.LabelEncoder() le.fit(x[\"Bldg_Type\"])  list(le.classes_)  le.transform(ames_prj[\"Bldg_Type\"]) Out[45]: <pre>array([1, 1, 1, ..., 1, 1, 1])</pre> In\u00a0[46]: Copied! <pre># Create a copy of the DataFrame and transform the 'Bldg_Type' column to float values\nx_copy = x.copy()\nx_copy['type'] = le.transform(x_copy[\"Bldg_Type\"])\n</pre> # Create a copy of the DataFrame and transform the 'Bldg_Type' column to float values x_copy = x.copy() x_copy['type'] = le.transform(x_copy[\"Bldg_Type\"]) In\u00a0[47]: Copied! <pre># Get the independent variables and the dependent variable\nX = x_copy[['Year_Built', 'type', 'Gr_Liv_Area']]\ny = ames_prj[['Sale_Price']]\n</pre> # Get the independent variables and the dependent variable X = x_copy[['Year_Built', 'type', 'Gr_Liv_Area']] y = ames_prj[['Sale_Price']] In\u00a0[48]: Copied! <pre>X\n</pre> X Out[48]: Year_Built type Gr_Liv_Area 0 1960 1 1656 1 1961 1 896 2 1958 1 1329 3 1968 1 2110 4 1997 1 1629 ... ... ... ... 2925 1984 1 1003 2926 1983 1 902 2927 1992 1 970 2928 1974 1 1389 2929 1993 1 2000 <p>2930 rows \u00d7 3 columns</p> In\u00a0[49]: Copied! <pre>y\n</pre> y Out[49]: Sale_Price 0 215000 1 105000 2 172000 3 244000 4 189900 ... ... 2925 142500 2926 131000 2927 132000 2928 170000 2929 188000 <p>2930 rows \u00d7 1 columns</p> In\u00a0[50]: Copied! <pre># Initiate a linear regressor \nreg = LinearRegression()\n\n# Initiate a random CV\nkf = KFold(n_splits = 10, shuffle=True, random_state=123)\n\n# evaluate the model and collect the results\nrandom_n_scores = cross_validate(reg, X, y.values.ravel(), \n                                scoring= ['neg_root_mean_squared_error', 'r2', 'neg_mean_absolute_error'], \n                                cv=kf, n_jobs=-1, error_score='raise')\n</pre> # Initiate a linear regressor  reg = LinearRegression()  # Initiate a random CV kf = KFold(n_splits = 10, shuffle=True, random_state=123)  # evaluate the model and collect the results random_n_scores = cross_validate(reg, X, y.values.ravel(),                                  scoring= ['neg_root_mean_squared_error', 'r2', 'neg_mean_absolute_error'],                                  cv=kf, n_jobs=-1, error_score='raise') In\u00a0[51]: Copied! <pre>random_n_scores\n</pre> random_n_scores Out[51]: <pre>{'fit_time': array([0.0150876 , 0.01461196, 0.07606864, 0.01363134, 0.01567721,\n        0.0122335 , 0.01297998, 0.00495601, 0.01281571, 0.0111711 ]),\n 'score_time': array([0.01175451, 0.00338268, 0.02259111, 0.00947595, 0.0103538 ,\n        0.01029325, 0.00297976, 0.01099586, 0.01003385, 0.00338864]),\n 'test_neg_root_mean_squared_error': array([-44622.40838673, -39772.65742074, -44832.52140754, -45450.03692245,\n        -50212.56009308, -49287.98884697, -39787.31970143, -52631.12777371,\n        -58187.6988452 , -38817.22221497]),\n 'test_r2': array([0.68186786, 0.65778112, 0.71220595, 0.68753325, 0.62837042,\n        0.6002097 , 0.69541257, 0.59591238, 0.61584596, 0.71330735]),\n 'test_neg_mean_absolute_error': array([-30212.75246135, -28792.38398508, -31229.5572116 , -32461.80017946,\n        -32897.03779732, -32580.57849056, -29550.97789663, -35188.52372995,\n        -35547.25333851, -28150.39632891])}</pre> In\u00a0[52]: Copied! <pre>rn_cv_r2 = np.mean(random_n_scores[\"test_r2\"])\nrn_cv_rmse = np.mean(abs(random_n_scores[\"test_neg_root_mean_squared_error\"]))\nrn_cv_mae = np.mean(abs(random_n_scores[\"test_neg_mean_absolute_error\"]))\n\nprint('R2 :',rn_cv_r2)\nprint('RMSE :',rn_cv_rmse)\nprint('MAE :',rn_cv_mae)\n</pre> rn_cv_r2 = np.mean(random_n_scores[\"test_r2\"]) rn_cv_rmse = np.mean(abs(random_n_scores[\"test_neg_root_mean_squared_error\"])) rn_cv_mae = np.mean(abs(random_n_scores[\"test_neg_mean_absolute_error\"]))  print('R2 :',rn_cv_r2) print('RMSE :',rn_cv_rmse) print('MAE :',rn_cv_mae) <pre>R2 : 0.6588446547591043\nRMSE : 46360.15416128094\nMAE : 31661.12614193703\n</pre> In\u00a0[53]: Copied! <pre># Initiate a leave group out cross valiadtion\ngroup_cvs =  LeaveOneGroupOut()\n\n# Evaluate the model and collect the results\nspatial_cluster_scores = cross_validate(reg, X, y.values.ravel(), \n                                scoring= ['neg_root_mean_squared_error', 'r2', 'neg_mean_absolute_error'], \n                                cv= group_cvs.split(X, y, ames_clusters.folds.values.ravel()), # spatial cross validation\n                                n_jobs=-1, error_score='raise')\n</pre> # Initiate a leave group out cross valiadtion group_cvs =  LeaveOneGroupOut()  # Evaluate the model and collect the results spatial_cluster_scores = cross_validate(reg, X, y.values.ravel(),                                  scoring= ['neg_root_mean_squared_error', 'r2', 'neg_mean_absolute_error'],                                  cv= group_cvs.split(X, y, ames_clusters.folds.values.ravel()), # spatial cross validation                                 n_jobs=-1, error_score='raise') In\u00a0[54]: Copied! <pre>spatial_cluster_scores\n</pre> spatial_cluster_scores Out[54]: <pre>{'fit_time': array([0.01505804, 0.01767373, 0.04996634, 0.01555181, 0.02358913,\n        0.02461791, 0.01460123, 0.03371215, 0.02450013, 0.01760197]),\n 'score_time': array([0.01214123, 0.0113101 , 0.01480627, 0.0123055 , 0.00381994,\n        0.00370812, 0.00353646, 0.01049113, 0.00463915, 0.00336456]),\n 'test_neg_root_mean_squared_error': array([-41955.22892416, -49279.43810801, -45746.18536977, -32873.9319184 ,\n        -53884.87755416, -83784.012911  , -54303.03783829, -37589.61688976,\n        -29506.44691955, -32487.42890339]),\n 'test_r2': array([0.50685433, 0.58938426, 0.42016374, 0.4765155 , 0.08934565,\n        0.2981662 , 0.37778871, 0.4231063 , 0.17653683, 0.09032787]),\n 'test_neg_mean_absolute_error': array([-31754.19616039, -35086.44507158, -33609.13258888, -23596.48589712,\n        -30780.25017551, -57463.25887411, -41568.85258424, -28509.48447583,\n        -21597.55002658, -25546.92881414])}</pre> In\u00a0[55]: Copied! <pre>sp_cv_r2 = np.mean(spatial_cluster_scores[\"test_r2\"])\nsp_cv_rmse = np.mean(abs(spatial_cluster_scores[\"test_neg_root_mean_squared_error\"]))\nsp_cv_mae = np.mean(abs(spatial_cluster_scores[\"test_neg_mean_absolute_error\"]))\n\nprint('R2 :',sp_cv_r2)\nprint('RMSE :',sp_cv_rmse)\nprint('MAE :',sp_cv_mae)\n</pre> sp_cv_r2 = np.mean(spatial_cluster_scores[\"test_r2\"]) sp_cv_rmse = np.mean(abs(spatial_cluster_scores[\"test_neg_root_mean_squared_error\"])) sp_cv_mae = np.mean(abs(spatial_cluster_scores[\"test_neg_mean_absolute_error\"]))  print('R2 :',sp_cv_r2) print('RMSE :',sp_cv_rmse) print('MAE :',sp_cv_mae) <pre>R2 : 0.344818938658986\nRMSE : 46141.02053364941\nMAE : 32951.25846683899\n</pre> In\u00a0[56]: Copied! <pre>random_n_scores['test_r2']\n</pre> random_n_scores['test_r2'] Out[56]: <pre>array([0.68186786, 0.65778112, 0.71220595, 0.68753325, 0.62837042,\n       0.6002097 , 0.69541257, 0.59591238, 0.61584596, 0.71330735])</pre> In\u00a0[57]: Copied! <pre>df_rn_cv_scores = pd.DataFrame({'r2': random_n_scores['test_r2'], \n             'rmse' :abs(random_n_scores['test_neg_root_mean_squared_error']),\n             'mae' : abs(random_n_scores[\"test_neg_mean_absolute_error\"]),\n            'cv_type' : 'Random CV'})\n</pre> df_rn_cv_scores = pd.DataFrame({'r2': random_n_scores['test_r2'],               'rmse' :abs(random_n_scores['test_neg_root_mean_squared_error']),              'mae' : abs(random_n_scores[\"test_neg_mean_absolute_error\"]),             'cv_type' : 'Random CV'}) In\u00a0[58]: Copied! <pre>df_rn_cv_scores\n</pre> df_rn_cv_scores Out[58]: r2 rmse mae cv_type 0 0.681868 44622.408387 30212.752461 Random CV 1 0.657781 39772.657421 28792.383985 Random CV 2 0.712206 44832.521408 31229.557212 Random CV 3 0.687533 45450.036922 32461.800179 Random CV 4 0.628370 50212.560093 32897.037797 Random CV 5 0.600210 49287.988847 32580.578491 Random CV 6 0.695413 39787.319701 29550.977897 Random CV 7 0.595912 52631.127774 35188.523730 Random CV 8 0.615846 58187.698845 35547.253339 Random CV 9 0.713307 38817.222215 28150.396329 Random CV In\u00a0[59]: Copied! <pre>df_sp_cv_scores = pd.DataFrame({'r2': spatial_cluster_scores['test_r2'], \n             'rmse' :abs(spatial_cluster_scores['test_neg_root_mean_squared_error']),\n             'mae' : abs(spatial_cluster_scores[\"test_neg_mean_absolute_error\"]),\n            'cv_type' : 'Spatial CV'})\n</pre> df_sp_cv_scores = pd.DataFrame({'r2': spatial_cluster_scores['test_r2'],               'rmse' :abs(spatial_cluster_scores['test_neg_root_mean_squared_error']),              'mae' : abs(spatial_cluster_scores[\"test_neg_mean_absolute_error\"]),             'cv_type' : 'Spatial CV'}) In\u00a0[60]: Copied! <pre>df_sp_cv_scores\n</pre> df_sp_cv_scores Out[60]: r2 rmse mae cv_type 0 0.506854 41955.228924 31754.196160 Spatial CV 1 0.589384 49279.438108 35086.445072 Spatial CV 2 0.420164 45746.185370 33609.132589 Spatial CV 3 0.476515 32873.931918 23596.485897 Spatial CV 4 0.089346 53884.877554 30780.250176 Spatial CV 5 0.298166 83784.012911 57463.258874 Spatial CV 6 0.377789 54303.037838 41568.852584 Spatial CV 7 0.423106 37589.616890 28509.484476 Spatial CV 8 0.176537 29506.446920 21597.550027 Spatial CV 9 0.090328 32487.428903 25546.928814 Spatial CV In\u00a0[61]: Copied! <pre>cv_metrics = pd.concat([df_rn_cv_scores, df_sp_cv_scores])\n</pre> cv_metrics = pd.concat([df_rn_cv_scores, df_sp_cv_scores]) In\u00a0[62]: Copied! <pre>cv_metrics\n</pre> cv_metrics Out[62]: r2 rmse mae cv_type 0 0.681868 44622.408387 30212.752461 Random CV 1 0.657781 39772.657421 28792.383985 Random CV 2 0.712206 44832.521408 31229.557212 Random CV 3 0.687533 45450.036922 32461.800179 Random CV 4 0.628370 50212.560093 32897.037797 Random CV 5 0.600210 49287.988847 32580.578491 Random CV 6 0.695413 39787.319701 29550.977897 Random CV 7 0.595912 52631.127774 35188.523730 Random CV 8 0.615846 58187.698845 35547.253339 Random CV 9 0.713307 38817.222215 28150.396329 Random CV 0 0.506854 41955.228924 31754.196160 Spatial CV 1 0.589384 49279.438108 35086.445072 Spatial CV 2 0.420164 45746.185370 33609.132589 Spatial CV 3 0.476515 32873.931918 23596.485897 Spatial CV 4 0.089346 53884.877554 30780.250176 Spatial CV 5 0.298166 83784.012911 57463.258874 Spatial CV 6 0.377789 54303.037838 41568.852584 Spatial CV 7 0.423106 37589.616890 28509.484476 Spatial CV 8 0.176537 29506.446920 21597.550027 Spatial CV 9 0.090328 32487.428903 25546.928814 Spatial CV In\u00a0[63]: Copied! <pre>fig, ax =  plt.subplots(1, 3, figsize=(12, 4))\n\nmy_colors = {'Random CV': '#1f77b4', 'Spatial CV': '#ff7f0e', 'C': 'gold'}\n\nsns.boxplot(data = cv_metrics,\n            hue = 'cv_type', \n            x = 'cv_type',\n            y = 'r2',  \n            dodge=False, width = .3, linewidth = 1, ax = ax[0],\n            #palette= 'coolwarm',\n            palette = my_colors,\n            showmeans=True, meanprops={\"markersize\": \"2.5\", \"markerfacecolor\" : \"#ef3b2c\",\n                    \"markeredgecolor\" : \"#ef3b2c\"} ,flierprops=dict(markersize=3))\n\nax[0].set_title( r'$R^2$',fontsize=11)\nax[0].set_ylabel('')\nax[0].set_xlabel('')\nax[0].set_ylim(0, 1)\nax[0].tick_params(labelsize = 9)\nax[0].legend([],[], frameon=False)\n\n#\nsns.boxplot(data = cv_metrics,\n            hue = 'cv_type', \n            x = 'cv_type',\n            y = 'rmse',  \n            dodge=False, width = .3, linewidth = 1, ax = ax[1],\n            #palette= 'coolwarm',\n            palette = my_colors,\n           showmeans=True, meanprops={\"markersize\": \"2.5\",  \"markerfacecolor\" : \"#ef3b2c\",\n                    \"markeredgecolor\" : \"#ef3b2c\"},  flierprops=dict(markersize=3))\nax[1].set_title('RMSE',fontsize=11)\nax[1].set_ylabel('')\nax[1].set_xlabel('')\nax[1].tick_params(labelsize = 9)\nax[1].legend([],[], frameon=False)\n\nsns.boxplot(data = cv_metrics,\n            hue = 'cv_type',\n            x = 'cv_type',\n            y = 'mae',  \n            dodge=False, width = .3, linewidth = 1, ax = ax[2],\n            #palette= 'coolwarm',\n            palette = my_colors,\n           showmeans=True, meanprops={\"markersize\": \"2.5\",  \"markerfacecolor\" : \"#ef3b2c\",\n                    \"markeredgecolor\" : \"#ef3b2c\"},  flierprops=dict(markersize=3))\nax[2].set_title('MAE',fontsize=11)\nax[2].set_ylabel('')\nax[2].set_xlabel('')\nax[2].tick_params(labelsize = 9)\n\nplt.legend([],[], frameon=False)\nplt.show()\n</pre> fig, ax =  plt.subplots(1, 3, figsize=(12, 4))  my_colors = {'Random CV': '#1f77b4', 'Spatial CV': '#ff7f0e', 'C': 'gold'}  sns.boxplot(data = cv_metrics,             hue = 'cv_type',              x = 'cv_type',             y = 'r2',               dodge=False, width = .3, linewidth = 1, ax = ax[0],             #palette= 'coolwarm',             palette = my_colors,             showmeans=True, meanprops={\"markersize\": \"2.5\", \"markerfacecolor\" : \"#ef3b2c\",                     \"markeredgecolor\" : \"#ef3b2c\"} ,flierprops=dict(markersize=3))  ax[0].set_title( r'$R^2$',fontsize=11) ax[0].set_ylabel('') ax[0].set_xlabel('') ax[0].set_ylim(0, 1) ax[0].tick_params(labelsize = 9) ax[0].legend([],[], frameon=False)  # sns.boxplot(data = cv_metrics,             hue = 'cv_type',              x = 'cv_type',             y = 'rmse',               dodge=False, width = .3, linewidth = 1, ax = ax[1],             #palette= 'coolwarm',             palette = my_colors,            showmeans=True, meanprops={\"markersize\": \"2.5\",  \"markerfacecolor\" : \"#ef3b2c\",                     \"markeredgecolor\" : \"#ef3b2c\"},  flierprops=dict(markersize=3)) ax[1].set_title('RMSE',fontsize=11) ax[1].set_ylabel('') ax[1].set_xlabel('') ax[1].tick_params(labelsize = 9) ax[1].legend([],[], frameon=False)  sns.boxplot(data = cv_metrics,             hue = 'cv_type',             x = 'cv_type',             y = 'mae',               dodge=False, width = .3, linewidth = 1, ax = ax[2],             #palette= 'coolwarm',             palette = my_colors,            showmeans=True, meanprops={\"markersize\": \"2.5\",  \"markerfacecolor\" : \"#ef3b2c\",                     \"markeredgecolor\" : \"#ef3b2c\"},  flierprops=dict(markersize=3)) ax[2].set_title('MAE',fontsize=11) ax[2].set_ylabel('') ax[2].set_xlabel('') ax[2].tick_params(labelsize = 9)  plt.legend([],[], frameon=False) plt.show()"},{"location":"notebooks/spatialkfold_intro/#i-spatial-resampling","title":"I. Spatial Resampling\u00b6","text":""},{"location":"notebooks/spatialkfold_intro/#1-spatial-cluster-resampling","title":"1. Spatial cluster resampling\u00b6","text":"<p>Two clustering algorithms are supported:</p> <ul> <li>KMeans (By default)</li> <li>BisectingKMeans</li> </ul>"},{"location":"notebooks/spatialkfold_intro/#11-using-kmeans","title":"1.1 Using KMeans\u00b6","text":""},{"location":"notebooks/spatialkfold_intro/#12-using-bisectingkmeans","title":"1.2 Using BisectingKMeans\u00b6","text":""},{"location":"notebooks/spatialkfold_intro/#2-spatial-blocks","title":"2. Spatial Blocks\u00b6","text":""},{"location":"notebooks/spatialkfold_intro/#21-spatial-resampled-random-blocks","title":"2.1 Spatial resampled random blocks\u00b6","text":""},{"location":"notebooks/spatialkfold_intro/#22-continuous-spatial-resampled-blocks","title":"2.2 Continuous spatial resampled blocks\u00b6","text":"<p>Two option are availble with orientation :</p> <ul> <li>'tb-lr' : top-bottom, left-right</li> <li>''bt-rl' : bottom-top, right-left</li> </ul>"},{"location":"notebooks/spatialkfold_intro/#221-tb-lr-top-bottom-left-right","title":"2.2.1. 'tb-lr' : top-bottom, left-right\u00b6","text":""},{"location":"notebooks/spatialkfold_intro/#222-bt-rl-bottom-top-right-left","title":"2.2.2. 'bt-rl' : bottom-top, right-left\u00b6","text":""},{"location":"notebooks/spatialkfold_intro/#3-plotting-function","title":"3. Plotting function\u00b6","text":"<p>Plot the partitioning of the data at each fold</p>"},{"location":"notebooks/spatialkfold_intro/#ii-comparaison-random-vs-spatial-cross-validataion","title":"II. Comparaison : Random VS Spatial Cross validataion\u00b6","text":""},{"location":"notebooks/spatialkfold_intro/#1-random-cv","title":"1. Random CV\u00b6","text":""},{"location":"notebooks/spatialkfold_intro/#spatial-cv","title":"Spatial CV:\u00b6","text":"<p>Using a Leave Region Out Cross vlidation</p>"}]}